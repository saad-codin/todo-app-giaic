# Implementation Plan: Local Kubernetes Deployment for Todo Chatbot

**Branch**: `005-local-k8s-deployment` | **Date**: 2026-01-19 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/005-local-k8s-deployment/spec.md`

## Summary

Deploy the Phase III AI-Powered Todo Chatbot to a local Kubernetes cluster using Docker containerization and Helm charts. This enables developers to test Kubernetes deployment workflows locally before cloud deployment (Phase V). The approach uses Minikube as the local cluster, Docker multi-stage builds for optimized container images, and Helm 3 for templated, reproducible deployments.

## Technical Context

**Language/Version**: Dockerfile, YAML, Bash scripts
**Primary Dependencies**: Docker, Minikube 1.32+, Helm 3.13+, kubectl 1.28+
**Storage**: External Neon PostgreSQL (existing from Phase III)
**Testing**: Manual deployment verification, health checks, end-to-end tests
**Target Platform**: Local Minikube cluster (Windows/macOS/Linux)
**Project Type**: Infrastructure/DevOps (extending existing web application)
**Performance Goals**: Full deployment in under 3 minutes, pod startup in under 30 seconds
**Constraints**: 4GB RAM minimum for Minikube, local-only (no cloud services)
**Scale/Scope**: 2 pods (frontend + backend), single namespace

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Correctness First | PASS | Deployment matches spec requirements exactly |
| II. Deterministic Behavior | PASS | K8s manifests are declarative and reproducible |
| III. Incremental Evolution | PASS | Builds on working Phase III app without changes |
| IV. Simplicity Before Scale | PASS | Minimal K8s resources, no premature optimization |
| V. Observability | PASS | Health checks, logs, and status commands included |

**Phase IV Specific Requirements** (from Constitution):
- [x] All services containerized with Docker
- [x] Kubernetes manifests via Helm charts, reproducible locally via Minikube
- [x] kubectl-ai for operational assistance only (documented, not required)
- [x] All Kubernetes resources declarative and version-controlled
- [x] No cloud-managed services (local deployment only)
- [x] No vendor-specific Kubernetes extensions
- [x] All configuration explicit (no implicit defaults)

## Project Structure

### Documentation (this feature)

```text
specs/005-local-k8s-deployment/
├── plan.md              # This file
├── research.md          # Technology decisions
├── quickstart.md        # Setup and deployment guide
├── contracts/
│   ├── helm-values.yaml        # Helm values contract
│   └── kubernetes-resources.yaml # K8s resource definitions
├── checklists/
│   └── requirements.md  # Quality checklist
└── tasks.md             # Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
# Existing application (unchanged)
backend/
├── main.py              # FastAPI entry point
├── requirements.txt     # Python dependencies
├── routes/              # API routes
├── agent/               # AI agent with MCP tools
└── ...

frontend/
├── package.json         # Node dependencies
├── next.config.js       # Next.js configuration
├── src/                 # React components and pages
└── ...

# NEW: Containerization and Deployment
Dockerfile.frontend      # Frontend multi-stage build
Dockerfile.backend       # Backend multi-stage build

helm/
└── todo-chatbot/
    ├── Chart.yaml           # Helm chart metadata
    ├── values.yaml          # Default values
    ├── values-local.yaml    # Local overrides (gitignored)
    └── templates/
        ├── _helpers.tpl
        ├── namespace.yaml
        ├── configmap.yaml
        ├── secret.yaml
        ├── frontend-deployment.yaml
        ├── frontend-service.yaml
        ├── backend-deployment.yaml
        └── backend-service.yaml

scripts/
├── minikube-setup.sh    # Minikube initialization
├── build-images.sh      # Container build script
└── deploy.sh            # Helm deployment script
```

**Structure Decision**: Infrastructure files added at repository root level. Helm chart in dedicated `helm/` directory. Helper scripts in `scripts/` directory. No changes to existing application code.

## Implementation Phases

### Phase 1: Containerization (P1 - User Story 1)

**Deliverables**:
1. `Dockerfile.frontend` - Multi-stage Next.js build
2. `Dockerfile.backend` - Multi-stage FastAPI build
3. `.dockerignore` - Exclude unnecessary files

**Frontend Dockerfile Strategy**:
```dockerfile
# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

# Stage 3: Runtime
FROM node:20-alpine AS runner
WORKDIR /app
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/public ./public
USER nextjs
EXPOSE 3000
CMD ["node", "server.js"]
```

**Backend Dockerfile Strategy**:
```dockerfile
# Stage 1: Build
FROM python:3.11-slim AS builder
WORKDIR /app
RUN pip install --user --no-cache-dir -r requirements.txt

# Stage 2: Runtime
FROM python:3.11-slim AS runner
WORKDIR /app
RUN useradd --create-home appuser
COPY --from=builder /root/.local /home/appuser/.local
COPY . .
USER appuser
ENV PATH=/home/appuser/.local/bin:$PATH
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**Acceptance Criteria**:
- `docker build -f Dockerfile.frontend -t todo-frontend .` succeeds
- `docker build -f Dockerfile.backend -t todo-backend .` succeeds
- `docker run todo-frontend` starts Next.js on port 3000
- `docker run todo-backend` starts FastAPI on port 8000

### Phase 2: Kubernetes Deployment (P2 - User Story 2)

**Deliverables**:
1. Namespace definition
2. ConfigMap for environment variables
3. Secret for sensitive data
4. Backend Deployment and Service
5. Frontend Deployment and Service

**Key Design Decisions**:
- ClusterIP services (no external exposure by default)
- Resource limits to prevent runaway containers
- Health checks for automatic recovery
- Labels for service discovery

**Acceptance Criteria**:
- `kubectl get pods -n todo-chatbot` shows 2 Running pods
- `kubectl get svc -n todo-chatbot` shows 2 services
- Backend responds to `/health` endpoint
- Frontend accessible via `minikube service`

### Phase 3: Helm Chart (P3 - User Story 3)

**Deliverables**:
1. `Chart.yaml` with metadata
2. `values.yaml` with defaults
3. Templates for all resources
4. `_helpers.tpl` for common labels
5. README for chart usage

**Values Structure**:
```yaml
frontend:
  replicaCount: 1
  image: { repository: todo-frontend, tag: latest }
  service: { type: ClusterIP, port: 3000 }
  resources: { limits: {...}, requests: {...} }
  env: { NEXT_PUBLIC_API_URL: "..." }

backend:
  replicaCount: 1
  image: { repository: todo-backend, tag: latest }
  service: { type: ClusterIP, port: 8000 }
  resources: { limits: {...}, requests: {...} }
  secrets: { DATABASE_URL: "", OPENAI_API_KEY: "", ... }
```

**Acceptance Criteria**:
- `helm lint ./helm/todo-chatbot` passes
- `helm install todo-chatbot ./helm/todo-chatbot -n todo-chatbot` succeeds
- `helm upgrade todo-chatbot ./helm/todo-chatbot -n todo-chatbot` works
- `helm list -n todo-chatbot` shows release

### Phase 4: End-to-End Validation (P4 - User Story 4)

**Deliverables**:
1. Deployment verification script
2. End-to-end test checklist
3. Troubleshooting guide

**Test Scenarios**:
1. Access frontend via browser
2. Sign in with existing credentials
3. Create task via chat: "Create a task to test Kubernetes"
4. List tasks via chat: "Show my tasks"
5. Complete task via chat: "Complete the Kubernetes test task"

**Acceptance Criteria**:
- All chat operations work as in Phase III
- No degradation in response time
- Logs accessible via `kubectl logs`

### Phase 5: AI DevOps Documentation (P5 - User Story 5)

**Deliverables**:
1. kubectl-ai usage examples in quickstart.md
2. Common operational queries documented
3. Alternative tools mentioned (k9s, lens)

**Example kubectl-ai Commands**:
```bash
kubectl-ai "show pod status in todo-chatbot namespace"
kubectl-ai "why is the backend pod crashing?"
kubectl-ai "how much memory is the frontend using?"
kubectl-ai "show me the logs for the last error"
```

**Acceptance Criteria**:
- kubectl-ai installation documented
- At least 5 example commands provided
- Alternatives documented for users without kubectl-ai

## Complexity Tracking

> No constitution violations identified. All decisions align with Phase IV requirements.

| Decision | Rationale |
|----------|-----------|
| Helm over raw manifests | Spec requirement (FR-006), templating for values |
| ClusterIP over NodePort | Simpler, use minikube tunnel for access |
| External Neon DB | Reuse existing Phase III setup, avoid in-cluster DB complexity |
| Multi-stage builds | FR-009 requires size and security best practices |

## Dependencies and Risks

| Dependency | Risk Level | Mitigation |
|------------|------------|------------|
| Docker Desktop | Low | Well-documented, widely available |
| Minikube | Low | Portable, good documentation |
| Helm CLI | Low | Standard K8s tooling |
| Neon DB connectivity | Medium | Test early, document network requirements |
| kubectl-ai availability | Low | Optional, document alternatives |

## Success Metrics

From spec SC-001 to SC-006:

| Metric | Target | Measurement |
|--------|--------|-------------|
| Container build time | < 5 minutes | `time docker build ...` |
| Deployment time | < 3 minutes | `time helm install ...` |
| Access latency | < 30 seconds | Time from deployment to browser |
| Feature parity | 100% | All Phase III features work |
| Helm upgrade | Zero downtime | Rolling update verification |
| Documentation | Complete | All steps reproducible |

## Next Steps

Run `/sp.tasks` to generate the implementation task list from this plan.
